<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>GOLDINU Presale</title>

  <!-- Custom Domain Root Site -->
  <base href="/">

  <style>
    :root{
      --bg:#05060a;
      --txt:#f7f3e8;
      --muted: rgba(247,243,232,.74);

      --gold1:#ffe2a6;
      --gold2:#ffbf4a;
      --gold3:#b77a1f;

      --line: rgba(255,215,120,.18);
      --line2: rgba(255,215,120,.30);

      --glass1: rgba(12,14,20,.74);
      --glass2: rgba(10,12,18,.52);

      --shadow: 0 18px 85px rgba(0,0,0,.62);
      --glow: 0 0 0 1px rgba(255,215,120,.10) inset, 0 0 34px rgba(255,190,90,.14), 0 0 90px rgba(255,140,30,.10);
      --glow2: 0 0 0 1px rgba(255,215,120,.14) inset, 0 0 38px rgba(255,180,80,.10);

      --framePad: 14px;
      --wrapPadX: 10px;

      --ease: cubic-bezier(.2,.8,.2,1);
    }

    *{box-sizing:border-box}
    html{height:100%; -webkit-text-size-adjust:100%}

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--txt);
      background:
        radial-gradient(1200px 700px at 18% -10%, rgba(255,190,90,.18), transparent 55%),
        radial-gradient(900px 650px at 82% 0%, rgba(255,140,30,.14), transparent 60%),
        radial-gradient(900px 650px at 50% 110%, rgba(85,255,170,.08), transparent 60%),
        linear-gradient(180deg, rgba(255,215,120,.04), transparent 35%),
        var(--bg);
      min-height:100vh;
      min-height:100svh;
      min-height:100dvh;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      overflow-x:hidden;
    }

    .grain{
      position:fixed; inset:0;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.75' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.18'/%3E%3C/svg%3E");
      mix-blend-mode:overlay;
      opacity:.15;
      z-index:-1;
      pointer-events:none;
    }

    .wrap{
      width:100%;
      max-width:1120px;
      margin:0 auto;
      padding: 0 var(--wrapPadX) 70px;
    }

    .frame{
      border-radius: 28px;
      border: 1px solid var(--line2);
      background:
        radial-gradient(980px 420px at 10% 0%, rgba(255,210,120,.10), transparent 55%),
        radial-gradient(980px 420px at 90% 0%, rgba(90,255,180,.06), transparent 55%),
        rgba(0,0,0,.22);
      box-shadow: 0 0 0 1px rgba(255,215,120,.10) inset, var(--shadow);
      backdrop-filter: blur(14px);
      padding:0;
      overflow:hidden;
      position:relative;
    }

    .heroPoster{
      margin: var(--framePad);
      border-radius: 24px;
      overflow:hidden;
      border: 1px solid rgba(255,215,120,.24);
      box-shadow: 0 0 0 1px rgba(255,215,120,.10) inset, 0 18px 60px rgba(0,0,0,.55);
      background: rgba(0,0,0,.18);
      position:relative;
    }
    .heroPoster img{ width:100%; height:auto; display:block; }

    @keyframes sweep {
      0% { transform: translateX(-55%) rotate(12deg); opacity:0; }
      18%{opacity:.20}
      60%{opacity:.20}
      100%{ transform: translateX(55%) rotate(12deg); opacity:0; }
    }
    .heroPoster::before{
      content:"";
      position:absolute; inset:-40%;
      background: linear-gradient(90deg, transparent, rgba(255,215,120,.22), transparent);
      transform: rotate(12deg);
      animation: sweep 5.2s var(--ease) infinite;
      pointer-events:none;
    }
    .heroPoster::after{ content:""; }

    .inner{ padding: var(--framePad); padding-top: 2px; }

    .miniTabs{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      margin: 0 var(--framePad) var(--framePad);
    }

    .btn{
      border:1px solid rgba(255,215,120,.22);
      background: linear-gradient(180deg, rgba(14,16,24,.72), rgba(10,12,18,.54));
      color:var(--txt);
      padding:10px 14px;
      border-radius: 999px;
      cursor:pointer;
      transition: transform .14s var(--ease), border-color .14s var(--ease), box-shadow .14s var(--ease);
      box-shadow: 0 10px 26px rgba(0,0,0,.25);
      backdrop-filter: blur(10px);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      font-size:16px;
    }
    .btn:hover{transform: translateY(-1px); border-color: rgba(255,215,120,.38);}
    .btn:active{transform: translateY(0px) scale(.99)}
    .btn--active{
      border-color: rgba(255,215,120,.60);
      box-shadow: 0 0 0 2px rgba(255,215,120,.10) inset, 0 0 30px rgba(255,190,90,.14);
    }

    .grid{
      display:grid;
      grid-template-columns: 1.12fr .88fr;
      gap:14px;
      margin-top:0;
    }
    @media(max-width: 900px){ .grid{grid-template-columns:1fr} }

    .card{
      border:1px solid var(--line);
      background:
        radial-gradient(700px 260px at 0% 0%, rgba(255,210,120,.08), transparent 60%),
        linear-gradient(180deg, rgba(12,14,20,.74), rgba(10,12,18,.56));
      border-radius: 22px;
      padding:16px;
      box-shadow: var(--glow);
      backdrop-filter: blur(12px);
      max-width:100%;
      min-width:0;
      position:relative;
    }
    .card--buy{
      background:
        radial-gradient(700px 300px at 10% 0%, rgba(255,210,120,.12), transparent 55%),
        radial-gradient(700px 300px at 90% 0%, rgba(70,255,170,.06), transparent 55%),
        linear-gradient(180deg, rgba(12,14,20,.78), rgba(10,12,18,.60));
    }

    .h1{
      font-size:32px;
      margin:0 0 8px;
      letter-spacing:.8px;
      text-shadow:0 1px 0 rgba(0,0,0,.65);
    }
    .sub{color:var(--muted);line-height:1.55; min-width:0;}
    .goldline{height:1px;margin:12px 0;background:linear-gradient(90deg, transparent, rgba(255,215,120,.70), transparent);opacity:.70}

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center; min-width:0;}
    .row > *{min-width:0;}

    input{
      width:100%;
      background: rgba(0,0,0,.34);
      border:1px solid rgba(255,215,120,.24);
      color:var(--txt);
      padding:12px 14px;
      border-radius:999px;
      outline:none;
      font-size:16px;
      min-width:0;
      transition: box-shadow .14s var(--ease), border-color .14s var(--ease);
    }
    input:focus{
      border-color: rgba(255,215,120,.60);
      box-shadow: 0 0 0 3px rgba(255,215,120,.12), 0 0 40px rgba(255,180,80,.08);
    }
    input:disabled{
      opacity:.55;
      cursor:not-allowed;
      filter: grayscale(.2);
    }

    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:10px 12px;
      border:1px solid rgba(255,215,120,.20);
      border-radius:999px;
      background: rgba(0,0,0,.24);
      color:var(--muted);
      max-width:100%;
      min-width:0;
      box-shadow: 0 0 0 1px rgba(255,215,120,.06) inset;
    }

    .breakAny{ overflow-wrap:anywhere; word-break:break-word; }
    code{
      color:var(--txt);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas;
      background:rgba(0,0,0,.26);
      padding:3px 10px;
      border-radius:999px;
      overflow-wrap:anywhere;
      word-break:break-word;
      border:1px solid rgba(255,215,120,.14);
    }

    .bigBtn{
      border:1px solid rgba(255,215,120,.34);
      background:
        radial-gradient(120px 60px at 25% 0%, rgba(255,255,255,.10), transparent 55%),
        linear-gradient(180deg, rgba(255,215,120,.22), rgba(0,0,0,.28));
      padding:12px 16px;
      border-radius:999px;
      color:var(--txt);
      cursor:pointer;
      box-shadow: 0 0 0 1px rgba(255,215,120,.10) inset, 0 18px 40px rgba(0,0,0,.35);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
      font-size:16px;
      font-weight:800;
      letter-spacing:.2px;
      transition: transform .14s var(--ease), box-shadow .14s var(--ease), border-color .14s var(--ease);
    }
    .bigBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(255,215,120,.55);
      box-shadow: 0 0 0 1px rgba(255,215,120,.12) inset, 0 0 46px rgba(255,190,90,.14);
    }
    .bigBtn:active{ transform: translateY(0) scale(.99); }
    .bigBtn:disabled{
      opacity:.55;
      cursor:not-allowed;
      transform:none !important;
      box-shadow: 0 0 0 1px rgba(255,215,120,.10) inset, 0 18px 40px rgba(0,0,0,.25);
    }

    .tableWrap{
      width:100%;
      overflow-x:auto;
      -webkit-overflow-scrolling: touch;
      border-radius:16px;
      border:1px solid rgba(255,215,120,.12);
      background: rgba(0,0,0,.18);
    }
    table{width:100%; border-collapse:collapse; margin-top:10px; min-width:520px;}
    th,td{border-bottom:1px solid rgba(255,215,120,.10); padding:11px 10px; text-align:left; white-space:nowrap;}
    th{color:rgba(247,243,232,.74); font-weight:900; letter-spacing:.2px}
    tbody tr:hover td{ background: rgba(255,215,120,.04); }
    .hide{display:none}

    .imgFrame{
      border:1px solid rgba(255,215,120,.20);
      border-radius:18px;
      overflow:hidden;
      box-shadow: var(--glow2);
      background: rgba(0,0,0,.22);
    }
    .imgFrame img{display:block;width:100%;height:auto}

    .kpiGrid{display:grid;grid-template-columns: repeat(3, 1fr);gap:10px;margin-top:10px}
    @media(max-width:700px){.kpiGrid{grid-template-columns:1fr}}
    .kpi{
      padding:12px;
      border:1px solid rgba(255,215,120,.14);
      border-radius:16px;
      background:
        radial-gradient(220px 120px at 15% 0%, rgba(70,255,170,.06), transparent 55%),
        rgba(0,0,0,.18)
    }
    .kpi b{display:block;font-size:16px}
    .kpi span{color:var(--muted);font-size:13px}

    .roadmap{display:grid;gap:10px;margin-top:12px}
    .rmItem{
      display:flex; gap:12px; align-items:flex-start;
      padding:12px;
      border:1px solid rgba(255,215,120,.14);
      border-radius:16px;
      background:
        radial-gradient(240px 120px at 0% 0%, rgba(255,210,120,.08), transparent 55%),
        rgba(0,0,0,.16)
    }
    .dot{
      width:12px;height:12px;border-radius:999px;
      background: radial-gradient(circle at 30% 30%, var(--gold1), var(--gold3));
      margin-top:6px; flex:0 0 12px;
      box-shadow:0 0 18px rgba(255,200,90,.26)
    }
    .rmItem b{display:block}
    .rmItem p{margin:4px 0 0;color:var(--muted);line-height:1.35}

    .footerNote{margin-top:10px;color:rgba(247,243,232,.66);font-size:12.5px;line-height:1.45}

    a.btn{ display:inline-flex; align-items:center; justify-content:center; text-decoration:none; gap:10px; }

    a.btn[href*="x.com/goldinu99"]{
      border-color: rgba(255,255,255,.18) !important;
      background: rgba(0,0,0,.82) !important;
      color: #fff !important;
      box-shadow: 0 10px 30px rgba(0,0,0,.35) !important;
    }
    a.btn[href*="x.com/goldinu99"]::before{
      content:"X";
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width: 26px;
      height: 26px;
      border-radius: 8px;
      background:#000;
      color:#fff;
      font-weight:900;
      letter-spacing:.5px;
      margin-right:8px;
      box-shadow: 0 0 0 1px rgba(255,255,255,.18) inset;
    }

    /* Referral section box ("Abteil") */
    .refBox{
      margin-top:12px;
      border:1px solid rgba(255,215,120,.14);
      border-radius:18px;
      background: rgba(0,0,0,.16);
      box-shadow: 0 0 0 1px rgba(255,215,120,.06) inset;
      padding:12px;
    }

    /* Rewards details (USDT) */
    details.rewards{
      margin-top:10px;
      border:1px solid rgba(255,215,120,.14);
      border-radius:18px;
      background: rgba(0,0,0,.18);
      box-shadow: 0 0 0 1px rgba(255,215,120,.06) inset;
      overflow:hidden;
    }
    details.rewards > summary{
      list-style:none;
      cursor:pointer;
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    details.rewards > summary::-webkit-details-marker{ display:none; }
    .rewardsTitle{ font-weight:900; letter-spacing:.2px; }
    .rewardsMeta{ color: var(--muted); white-space:nowrap; }
    .rewardsBody{ padding: 0 14px 14px; color: var(--muted); }
    .rewardsHr{
      height:1px;
      margin:0 14px 12px;
      background:linear-gradient(90deg, transparent, rgba(255,215,120,.55), transparent);
      opacity:.75;
    }
    .rewardList{ display:grid; gap:10px; }
    .rewardItem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px;
      border-radius:16px;
      border:1px solid rgba(255,215,120,.12);
      background: rgba(0,0,0,.20);
    }
    .rewardItem b{ color: var(--txt); }
    .badgeOk{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,215,120,.22);
      background: rgba(0,0,0,.22);
      color: var(--txt);
      font-weight:800;
    }

    /* ‚úÖ Countdown (BIG) */
    .countdownWrap{
      margin: 10px 0 14px;
      border:1px solid rgba(255,215,120,.18);
      border-radius:20px;
      background:
        radial-gradient(520px 220px at 20% 0%, rgba(255,210,120,.10), transparent 60%),
        rgba(0,0,0,.18);
      box-shadow: 0 0 0 1px rgba(255,215,120,.06) inset, 0 22px 70px rgba(0,0,0,.35);
      padding:14px;
      text-align:center;
    }
    .countdownTitle{
      font-weight:900;
      letter-spacing:.2px;
      margin-bottom:6px;
      color: rgba(247,243,232,.86);
    }
    .countdownTime{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas;
      font-weight:900;
      letter-spacing: 1.4px;
      font-size: 42px;
      line-height: 1.1;
      text-shadow: 0 1px 0 rgba(0,0,0,.65);
    }
    .countdownSub{
      margin-top:6px;
      color: var(--muted);
      font-size: 13.5px;
      line-height:1.35;
    }
    @media(max-width:520px){
      .h1{font-size:27px}
      .miniTabs{justify-content:space-between}
      table{min-width:480px;}
      .countdownTime{ font-size: 34px; }
    }
    @media (prefers-reduced-motion: reduce){
      .heroPoster::before{ animation:none; }
      .btn, .bigBtn{ transition:none; }
    }
  </style>
</head>

<body>
  <div class="grain"></div>

  <div class="wrap">
    <div class="frame">

      <div class="heroPoster">
        <img src="presalehero.jpg?v=21" alt="GOLDINU Hero Poster" />
      </div>

      <div class="miniTabs">
        <button id="tabPresale" class="btn btn--active">Presale</button>
        <button id="tabTokenomics" class="btn">Tokenomics</button>
      </div>

      <div class="inner">

        <div id="pagePresale">
          <div class="grid">
            <div class="card card--buy">
              <div class="h1">GOLDINU Presale üê∂</div>

              <!-- ‚úÖ BIG Countdown (12h) -->
              <div id="countdownWrap" class="countdownWrap">
                <div class="countdownTitle">Presale opens in</div>
                <div class="countdownTime" id="countdownTime">12:00:00</div>
                <div class="countdownSub" id="countdownSub">Buying is locked until the timer ends.</div>
              </div>

              <div class="sub">
                Send SOL to the official presale wallet. Minimum: <b><span id="minSolText"></span> SOL</b>.<br/>
                Please always verify the wallet address before sending.
              </div>

              <div class="goldline"></div>

              <!-- ‚úÖ Raised/Phase ABOVE buy input -->
              <div class="row">
                <span class="pill" id="phaseBadge">Phase: ‚Äî</span>
                <span class="pill" id="raisedBadge">Raised: ‚Äî SOL</span>
              </div>

              <!-- ‚úÖ Buy row -->
              <div style="margin-top:12px" class="row">
                <div style="flex:1; min-width:0">
                  <input id="amountSol" type="number" step="0.0001" min="0" placeholder="Amount in SOL (e.g. 0.2)" />
                </div>
                <button id="btnBuy" class="bigBtn">Buy</button>
              </div>

              <!-- ‚úÖ Connect + your wallet UNDER buy row -->
              <div style="margin-top:12px" class="row">
                <button id="btnConnect" class="bigBtn">Connect Phantom</button>
                <span class="pill">Your Wallet: <code id="kUserWallet">‚Äî</code></span>
              </div>

              <!-- ‚úÖ Referral section ("Abteil") -->
              <div class="refBox">
                <div class="row">
                  <span class="pill">Your Referral: <code id="kRefCode">‚Äî</code></span>
                  <button id="copyRef" class="btn">Copy Link</button>
                  <span class="pill">Referrals: <code id="kRefCount">0</code></span>
                </div>

                <!-- ‚úÖ USDT rewards info (counts your referrals and shows earned/next) -->
                <details id="rewardsBox" class="rewards">
                  <summary>
                    <div>
                      <div class="rewardsTitle">Referral Rewards (USDT)</div>
                      <div class="rewardsMeta" id="rewardsSummary">Earned: 0 USDT ‚Ä¢ Next: ‚Äî</div>
                    </div>
                    <span class="badgeOk">Open</span>
                  </summary>
                  <div class="rewardsHr"></div>
                  <div class="rewardsBody">
                    <div class="rewardList" id="rewardList"></div>
                    <div style="margin-top:10px">
                      Referral counts only after a successful buy.
                    </div>
                  </div>
                </details>

                <div style="margin-top:8px" class="sub breakAny" id="refInfo"></div>
              </div>

              <div style="margin-top:10px" id="txStatus" class="sub">Status: initializing‚Ä¶</div>
              <div style="margin-top:6px" class="sub" id="rpcStatus">RPC: ‚Äî</div>

              <div class="footerNote">
                Note: Contributions go directly on-chain to the official presale wallet. There is no refund logic on this page.
              </div>
            </div>

            <div class="card">
              <div class="row" style="justify-content:space-between">
                <b style="font-size:18px">Phases & Allocation</b>
                <button id="btnTokenomicsJump" class="btn">Tokenomics ‚Üí</button>
              </div>

              <div class="kpiGrid">
                <div class="kpi"><b>Supply</b><span>1,000,000,000 GOLDINU</span></div>
                <div class="kpi"><b>Presale</b><span>10 phases ‚Ä¢ rate decreases each phase</span></div>
                <div class="kpi"><b>LP</b><span>Locked at launch (plan)</span></div>
              </div>

              <div class="goldline"></div>

              <div class="tableWrap">
                <table id="phaseTable">
                  <thead>
                    <tr><th>Phase</th><th>Rate</th><th>SOL Cap</th><th>Token Cap</th></tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>
            </div>
          </div>
        </div>

        <div id="pageTokenomics" class="hide">
          <div class="grid">
            <div class="card">
              <div class="h1" style="font-size:28px;margin-bottom:6px">Tokenomics</div>
              <div class="sub">$GINU token distribution + presale phases. ‚ú®</div>

              <div class="goldline"></div>

              <div class="imgFrame">
                <img src="tokenomics.png?v=21" alt="GOLDINU Tokenomics" />
              </div>

              <div class="goldline"></div>

              <b style="font-size:18px">Roadmap</b>

              <div class="roadmap">
                <div class="rmItem"><div class="dot"></div><div>
                  <b>1) Community & Presale Launch</b>
                  <p>Building awareness, onboarding early supporters and expanding the community.</p>
                </div></div>

                <div class="rmItem"><div class="dot"></div><div>
                  <b>2) Raydium Launch & Liquidity Pools</b>
                  <p>SOL & USDC pools go live. Liquidity lock and trading begins.</p>
                </div></div>

                <div class="rmItem"><div class="dot"></div><div>
                  <b>3) Ecosystem Stability & Buybacks</b>
                  <p>Arbitrage opportunities for traders. Trading fees power buybacks & burns. Supply distribution reduces dump risk.</p>
                </div></div>

                <div class="rmItem"><div class="dot"></div><div>
                  <b>4) Cross-Chain Bridge Expansion</b>
                  <p>Bridges to additional blockchains increase liquidity & accessibility.</p>
                </div></div>

                <div class="rmItem"><div class="dot"></div><div>
                  <b>5) Digital Asset Integration</b>
                  <p>NFT & digital asset utility. Access to exclusive ecosystem features.</p>
                </div></div>

                <div class="rmItem"><div class="dot"></div><div>
                  <b>6) Strategic Listings & Partnerships</b>
                  <p>Centralized exchange listings. Market maker support and strategic alliances.</p>
                </div></div>
              </div>

              <div style="margin-top:14px" class="row">
                <button id="backToPresale" class="btn">‚¨Ö Back to Presale</button>
              </div>
            </div>

            <div class="card">
              <div class="row" style="gap:12px;align-items:center">
                <img src="goldinu.png?v=21" alt="Gold Inu Buddy" style="width:88px;height:88px;border-radius:22px;object-fit:cover;box-shadow:0 0 0 1px rgba(255,215,120,.25), var(--glow)" />
                <div>
                  <b style="font-size:18px">GOLDINU Buddy üêæ</b>
                  <div class="sub">Mascot presence for brand consistency on every page.</div>
                </div>
              </div>

              <div class="goldline"></div>

              <b style="font-size:18px">How presale works</b>
              <div class="sub" style="margin-top:6px">
                1) Connect Phantom<br/>
                2) Enter SOL amount (min. <span id="minSolText2"></span>)<br/>
                3) Click ‚ÄúBuy‚Äù ‚Üí SOL is sent directly to the presale wallet<br/>
                4) Phase badge updates automatically from wallet balance
              </div>

              <div class="goldline"></div>

              <b style="font-size:18px">Links</b>
              <div class="sub" style="margin-top:6px">
                ‚Ä¢ Solscan: verify wallet & transactions<br/><br/>
                <a href="https://t.me/+J__k1oecBRY1NjIy" target="_blank" class="btn">üì¢ Join Telegram</a>
                <a href="https://x.com/goldinu99?s=11" target="_blank" class="btn">üê¶ Follow on X</a>
              </div>
            </div>
          </div>
        </div>

      </div><!-- inner -->
    </div><!-- frame -->
  </div><!-- wrap -->

  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  <script>
    const PRESALE_WALLET = "6g2Kn6hgfFUGXH44dDHLGPFL5eQG6FqR346HgGUrCmx4";
    const MIN_SOL = 0.2;

    // ‚úÖ Countdown settings (12 hours). Starts instantly and persists per visitor via localStorage.
    const COUNTDOWN_SECONDS = 12 * 60 * 60;
    const COUNTDOWN_STORAGE_KEY = "goldinu_unlockAtMs";

    const START_BALANCE_SOL = 0;
    const REF_API_BASE = "https://goldinu-ref.goldinu.workers.dev";

    const RPC_LIST = [
      "https://solana-mainnet.g.alchemy.com/v2/uenOkKWZ9SOxMAXUPWvin",
      "https://api.mainnet-beta.solana.com",
      "https://rpc.ankr.com/solana"
    ];

    const PHASES = [
      { phase: 1,  rate: 1000000, solCap: 10.0,       tokenCap: 10000000 },
      { phase: 2,  rate: 900000,  solCap: 22.2222,    tokenCap: 20000000 },
      { phase: 3,  rate: 800000,  solCap: 37.5,       tokenCap: 30000000 },
      { phase: 4,  rate: 700000,  solCap: 57.1429,    tokenCap: 40000000 },
      { phase: 5,  rate: 600000,  solCap: 83.3333,    tokenCap: 50000000 },
      { phase: 6,  rate: 500000,  solCap: 120.0,      tokenCap: 60000000 },
      { phase: 7,  rate: 400000,  solCap: 175.0,      tokenCap: 70000000 },
      { phase: 8,  rate: 300000,  solCap: 200.0,      tokenCap: 60000000 },
      { phase: 9,  rate: 250000,  solCap: 160.0,      tokenCap: 40000000 },
      { phase:10,  rate: 200000,  solCap: 100.0,      tokenCap: 20000000 },
    ];

    // ‚úÖ Rewards tiers (USDT)
    const REWARD_TIERS = [
      { refs: 10,  usdt: 5 },
      { refs: 25,  usdt: 15 },
      { refs: 35,  usdt: 30 },
      { refs: 50,  usdt: 70 },
      { refs: 100, usdt: 150 },
      { refs: 200, usdt: 300 },
    ];

    const el = (id)=>document.getElementById(id);
    function shortAddr(a){ return a.slice(0,4)+"‚Ä¶"+a.slice(-5); }
    function formatNum(n){ return n.toLocaleString("en-US"); }
    function formatSol(n){ return (Math.round(n*10000)/10000).toString(); }
    function setStatus(msg){ el("txStatus").innerHTML = msg; }
    function setRpcStatus(msg){ el("rpcStatus").textContent = msg; }
    function setRefInfo(msg){ el("refInfo").innerHTML = msg || ""; }

    el("minSolText").textContent = MIN_SOL;
    el("minSolText2").textContent = MIN_SOL;

    // ‚úÖ Countdown logic: locks BUY until done, then hides countdown box.
    function ensureUnlockAt(){
      const existing = Number(localStorage.getItem(COUNTDOWN_STORAGE_KEY) || 0);
      if (existing && Number.isFinite(existing) && existing > Date.now() - 24*60*60*1000) return existing;
      const unlockAt = Date.now() + COUNTDOWN_SECONDS * 1000;
      localStorage.setItem(COUNTDOWN_STORAGE_KEY, String(unlockAt));
      return unlockAt;
    }

    function pad2(n){ return String(n).padStart(2,"0"); }
    function formatHMS(totalSeconds){
      const s = Math.max(0, Math.floor(totalSeconds));
      const hh = Math.floor(s / 3600);
      const mm = Math.floor((s % 3600) / 60);
      const ss = s % 60;
      return `${pad2(hh)}:${pad2(mm)}:${pad2(ss)}`;
    }

    let countdownTimer = null;
    let unlockAtMs = ensureUnlockAt();
    let buyUnlocked = false;

    function setBuyLocked(locked){
      const buyBtn = el("btnBuy");
      const amtIn = el("amountSol");
      if (!buyBtn || !amtIn) return;
      buyBtn.disabled = !!locked;
      amtIn.disabled = !!locked;
    }

    function tickCountdown(){
      const now = Date.now();
      const leftMs = unlockAtMs - now;
      const wrap = el("countdownWrap");
      const timeEl = el("countdownTime");
      const subEl = el("countdownSub");

      if (leftMs <= 0){
        buyUnlocked = true;
        setBuyLocked(false);
        if (wrap) wrap.style.display = "none";
        if (subEl) subEl.textContent = "";
        if (countdownTimer) clearInterval(countdownTimer);
        return;
      }

      buyUnlocked = false;
      setBuyLocked(true);

      const leftSec = leftMs / 1000;
      if (timeEl) timeEl.textContent = formatHMS(leftSec);
      if (subEl) subEl.textContent = "In 12 hours everyone can buy. Buying is locked until the timer ends.";
    }

    (function initCountdown(){
      // start immediately
      tickCountdown();
      countdownTimer = setInterval(tickCountdown, 1000);
    })();

    (function captureIncomingRef(){
      const params = new URLSearchParams(window.location.search);
      const ref = params.get("ref");
      if (ref && /^[A-Za-z0-9_-]{6,32}$/.test(ref)) {
        localStorage.setItem("incomingRef", ref);
        setRefInfo(`Referral detected ‚úÖ (<code>${ref}</code>) ‚Äî will count after successful buy.`);
      }
    })();

    const pagePresale = el("pagePresale");
    const pageTokenomics = el("pageTokenomics");
    const tabPresale = document.getElementById("tabPresale");
    const tabTokenomics = document.getElementById("tabTokenomics");

    function showPresale(){
      pagePresale.classList.remove("hide");
      pageTokenomics.classList.add("hide");
      tabPresale?.classList.add("btn--active");
      tabTokenomics?.classList.remove("btn--active");
      window.scrollTo({top:0,behavior:"smooth"});
    }
    function showTokenomics(){
      pagePresale.classList.add("hide");
      pageTokenomics.classList.remove("hide");
      tabTokenomics?.classList.add("btn--active");
      tabPresale?.classList.remove("btn--active");
      window.scrollTo({top:0,behavior:"smooth"});
    }

    tabPresale?.addEventListener("click", showPresale);
    tabTokenomics?.addEventListener("click", showTokenomics);
    el("btnTokenomicsJump").addEventListener("click", showTokenomics);
    el("backToPresale").addEventListener("click", showPresale);

    // ‚úÖ Tabelle: SOL Cap nur f√ºr Anzeige auf ganze Zahl aufrunden (Logik bleibt gleich)
    const tbody = document.querySelector("#phaseTable tbody");
    PHASES.forEach(p=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><b>Phase ${p.phase}</b></td>
        <td>${formatNum(p.rate)} GOLDINU</td>
        <td>${Math.ceil(p.solCap)} SOL</td>
        <td>${formatNum(p.tokenCap)} GOLDINU</td>
      `;
      tbody.appendChild(tr);
    });

    const { Connection, PublicKey, SystemProgram, Transaction, LAMPORTS_PER_SOL } = solanaWeb3;
    let connection = null;
    let currentRpcIndex = 0;

    async function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    async function probeRpc(url){
      const c = new Connection(url, "confirmed");
      const t0 = performance.now();
      await c.getLatestBlockhash("confirmed");
      const t1 = performance.now();
      return { url, latencyMs: Math.round(t1 - t0) };
    }

    function rpcLabel(url){
      if (url.includes("alchemy")) return "Alchemy";
      if (url.includes("ankr")) return "Ankr";
      return "Mainnet";
    }

    async function initConnection(){
      const results = [];
      for (const url of RPC_LIST){
        try{ results.push(await probeRpc(url)); } catch(e){}
      }
      if (!results.length){
        setRpcStatus("RPC: all endpoints failed");
        throw new Error("All RPC endpoints failed");
      }
      results.sort((a,b)=>a.latencyMs - b.latencyMs);
      const best = results[0];
      currentRpcIndex = RPC_LIST.indexOf(best.url);
      connection = new Connection(best.url, "confirmed");
      setRpcStatus(`RPC: ${rpcLabel(best.url)} (~${best.latencyMs}ms) ‚úÖ`);
    }

    async function switchToNextRpc(){
      for (let step = 1; step <= RPC_LIST.length; step++){
        const idx = (currentRpcIndex + step) % RPC_LIST.length;
        const url = RPC_LIST[idx];
        try{
          const c = new Connection(url, "confirmed");
          await c.getLatestBlockhash("confirmed");
          connection = c;
          currentRpcIndex = idx;
          setRpcStatus(`RPC switched: ${rpcLabel(url)} ‚úÖ`);
          return true;
        }catch(e){}
      }
      setRpcStatus("RPC switch failed");
      return false;
    }

    async function withRetries(fn, { tries = 3, delayMs = 350 } = {}){
      let lastErr = null;
      for (let i = 0; i < tries; i++){
        try{ return await fn(); }
        catch(e){
          lastErr = e;
          await switchToNextRpc();
          await sleep(delayMs * (i+1));
        }
      }
      throw lastErr;
    }

    let provider = null;
    let userPubkey = null;

    function getProvider(){
      if ("solana" in window) {
        const p = window.solana;
        if (p?.isPhantom) return p;
      }
      return null;
    }

    async function apiGet(path){
      const r = await fetch(`${REF_API_BASE}${path}`);
      if(!r.ok) throw new Error(await r.text());
      return await r.json();
    }
    async function apiPost(path, body){
      const r = await fetch(`${REF_API_BASE}${path}`,{
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body)
      });
      if(!r.ok) throw new Error(await r.text());
      return await r.json();
    }

    async function signChallenge(nonce){
      const msg = new TextEncoder().encode(`GOLDINU_REF:${nonce}`);
      const signed = await provider.signMessage(msg, "utf8");
      const sigB64 = btoa(String.fromCharCode(...signed.signature));
      return sigB64;
    }

    function buildRefLink(refCode){
      const origin = window.location.origin;
      const path = window.location.pathname;
      return `${origin}${path}?ref=${encodeURIComponent(refCode)}`;
    }

    // ‚úÖ Rewards helpers
    function calcRewardsSummary(refCount){
      let earned = 0;
      for (const t of REWARD_TIERS){
        if (refCount >= t.refs) earned = t.usdt;
      }
      const next = REWARD_TIERS.find(t => refCount < t.refs) || null;
      return { earned, next };
    }

    function renderRewards(refCount){
      const { earned, next } = calcRewardsSummary(refCount);
      el("rewardsSummary").textContent =
        next
          ? `Earned: ${earned} USDT ‚Ä¢ Next: ${next.refs} refs ‚Üí ${next.usdt} USDT`
          : `Earned: ${earned} USDT ‚Ä¢ Next: max tier ‚úÖ`;

      const list = el("rewardList");
      list.innerHTML = "";
      for (const t of REWARD_TIERS){
        const reached = refCount >= t.refs;
        const div = document.createElement("div");
        div.className = "rewardItem";
        div.innerHTML = `
          <div>
            <b>${t.refs} refs ‚Üí ${t.usdt} USDT</b><br/>
            <span>${reached ? "Unlocked ‚úÖ" : "Locked"}</span>
          </div>
          <div class="badgeOk">${reached ? "‚úì" : "‚Äî"}</div>
        `;
        list.appendChild(div);
      }
    }

    async function initReferralForConnectedWallet(){
      const wallet = userPubkey.toString();

      try{
        const { nonce } = await apiGet(`/challenge?wallet=${encodeURIComponent(wallet)}`);
        const signatureB64 = await signChallenge(nonce);

        const reg = await apiPost("/register", { wallet, nonce, signatureB64 });

        el("kRefCode").textContent = reg.refCode;
        const stats = await apiGet(`/stats?ref=${encodeURIComponent(reg.refCode)}`);
        const count = Number(stats.count || 0);
        el("kRefCount").textContent = String(count);

        // ‚úÖ update rewards based on your referral count
        renderRewards(count);

        const myLink = buildRefLink(reg.refCode);
        setRefInfo(`Your link: <code class="breakAny">${myLink}</code><br/>Referral counts only after a successful buy.`);

        el("copyRef").onclick = async ()=>{
          try{
            await navigator.clipboard.writeText(myLink);
            setStatus("Referral link copied ‚úÖ");
            setTimeout(()=>setStatus("Status: ready ‚úÖ"), 1000);
          }catch{
            setStatus("Copy failed. Please copy manually.");
          }
        };

      }catch(e){
        console.log("Referral init failed:", e?.message || e);
        setRefInfo(`Referral backend error.<br/><code class="breakAny">${REF_API_BASE}</code>`);
      }
    }

    async function connectWallet(){
      provider = getProvider();
      if (!provider){
        setStatus("Phantom not found. Install Phantom.");
        return;
      }
      try{
        const resp = await provider.connect();
        userPubkey = resp.publicKey;
        el("kUserWallet").textContent = shortAddr(userPubkey.toString());
        setStatus("Wallet connected ‚úÖ");

        await initReferralForConnectedWallet();
      }catch(e){
        setStatus("Connect canceled");
      }
    }

    async function getWalletSol(){
      const pub = new PublicKey(PRESALE_WALLET);
      return await withRetries(async ()=>{
        const lamports = await connection.getBalance(pub, "confirmed");
        return lamports / LAMPORTS_PER_SOL;
      });
    }

    function computeCurrentPhase(raisedSol){
      let cum = 0;
      for (const p of PHASES){
        cum += p.solCap;
        if (raisedSol < cum + 1e-9) return p.phase;
      }
      return PHASES[PHASES.length - 1].phase;
    }

    function totalSolCap(){ return PHASES.reduce((a,p)=>a + p.solCap, 0); }

    // ‚úÖ Only show Phase + Raised (NO "Left" anywhere)
    async function updatePhaseBadge(){
      try{
        const bal = await getWalletSol();
        const raised = Math.max(0, bal - START_BALANCE_SOL);
        const phase = computeCurrentPhase(raised);

        el("phaseBadge").textContent = `Phase: ${phase}`;
        el("raisedBadge").textContent = `Raised: ${formatSol(raised)} SOL`;
      }catch{
        el("phaseBadge").textContent = "Phase: ‚Äî (network)";
        el("raisedBadge").textContent = "Raised: ‚Äî SOL";
      }
    }

    async function capCheckOrBlock(amt){
      const cap = totalSolCap();
      const bal = await getWalletSol();
      const raised = Math.max(0, bal - START_BALANCE_SOL);
      if (raised + amt > cap + 1e-9){
        setStatus(`Sold out / cap reached.`);
        return false;
      }
      return true;
    }

    async function creditReferralAfterBuy(txSig, amountSol){
      const incoming = localStorage.getItem("incomingRef");
      if (!incoming) return;

      try{
        const wallet = userPubkey.toString();
        const { nonce } = await apiGet(`/challenge?wallet=${encodeURIComponent(wallet)}`);
        const signatureB64 = await signChallenge(nonce);

        await apiPost("/credit", {
          wallet,
          refCode: incoming,
          txSig,
          amountSol,
          nonce,
          signatureB64
        });

        localStorage.removeItem("incomingRef");
      }catch(e){
        console.log("credit failed:", e?.message || e);
      }
    }

    async function sendSol(){
      // ‚úÖ Block buying until countdown ends
      if (!buyUnlocked){
        setStatus("Presale is locked. Please wait for the countdown to end.");
        return;
      }

      if (!connection){
        setStatus("Initializing network‚Ä¶");
        await initConnection();
      }

      if (!userPubkey){
        await connectWallet();
        if (!userPubkey) return;
      }

      const amt = Number(el("amountSol").value);
      if (!amt || amt <= 0){ setStatus("Enter a valid SOL amount (e.g. 0.2)"); return; }
      if (amt < MIN_SOL){ setStatus(`Minimum is ${MIN_SOL} SOL`); return; }

      setStatus("Checking cap‚Ä¶");
      const ok = await capCheckOrBlock(amt);
      if (!ok) return;

      try{
        setStatus("Creating transaction‚Ä¶");
        const fromPubkey = userPubkey;
        const toPubkey = new PublicKey(PRESALE_WALLET);

        const tx = new Transaction().add(
          SystemProgram.transfer({
            fromPubkey,
            toPubkey,
            lamports: Math.round(amt * LAMPORTS_PER_SOL),
          })
        );

        tx.feePayer = fromPubkey;

        const { blockhash, lastValidBlockHeight } = await withRetries(
          async ()=> await connection.getLatestBlockhash("finalized"),
          { tries: 3 }
        );
        tx.recentBlockhash = blockhash;

        setStatus("Sign in Phantom‚Ä¶");
        const signed = await provider.signTransaction(tx);

        setStatus("Sending‚Ä¶");
        const sig = await withRetries(
          async ()=> await connection.sendRawTransaction(signed.serialize(), { skipPreflight: false }),
          { tries: 3 }
        );

        setStatus("Confirming‚Ä¶");
        await withRetries(async ()=>{
          return await connection.confirmTransaction(
            { signature: sig, blockhash, lastValidBlockHeight },
            "confirmed"
          );
        }, { tries: 3 });

        setStatus(`‚úÖ Success ‚Ä¢ TX: <a href="https://solscan.io/tx/${sig}" target="_blank" rel="noreferrer">${sig}</a>`);

        await creditReferralAfterBuy(sig, amt);

        // refresh raised/phase
        setTimeout(updatePhaseBadge, 1200);

        // refresh referral stats after buy
        if (userPubkey){
          try{ await initReferralForConnectedWallet(); }catch{}
        }

      }catch(e){
        await switchToNextRpc();
        setStatus("Error: " + (e?.message || e));
      }
    }

    el("btnConnect").addEventListener("click", connectWallet);
    el("btnBuy").addEventListener("click", sendSol);

    // show rewards even before connect (0)
    renderRewards(0);

    (async ()=>{
      try{
        setStatus("Initializing RPC‚Ä¶");
        await initConnection();
        setStatus("Status: ready ‚úÖ");
        await updatePhaseBadge();
        setInterval(updatePhaseBadge, 15000);
      }catch(e){
        setStatus("Network init failed");
      }
    })();
  </script>
</body>
</html>
